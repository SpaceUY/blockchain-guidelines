---
title: Safe Wallets & ERC 4337
layout: home
parent: Account Abstraction
ancestor: Ethereum Virtual Machine
permalink: /evm/developer-guide/smart-contracts/account-abstraction/safe-4337
nav_order: 1
---

# Safe Wallet & ERC-4337 Tutorial

A comprehensive guide to working with Safe (formerly Gnosis Safe) wallets and ERC-4337 Account Abstraction using Safe's Protocol Kit and Relay Kit.

> **ðŸ“ Note:** This tutorial is self-contained and provides complete, runnable code examples. If you're viewing this alongside a reference implementation folder, those files contain more advanced examples and patterns.

## ðŸ“‹ Table of Contents

1. [Prerequisites & Setup](#prerequisites--setup)
2. [Quick Start: Your First Safe Transaction](#quick-start-your-first-safe-transaction)
3. [Understanding Safe Wallets](#understanding-safe-wallets)
4. [Part 1: Basic Safe Operations (Protocol Kit)](#part-1-basic-safe-operations-protocol-kit)
5. [Part 2: ERC-4337 User Operations (Relay Kit)](#part-2-erc-4337-user-operations-relay-kit)
6. [Part 3: Advanced Topics](#part-3-advanced-topics)
7. [Troubleshooting](#troubleshooting)

---

## Prerequisites & Setup

### Required Knowledge
- Basic understanding of Ethereum wallets and transactions
- Familiarity with TypeScript/JavaScript
- Understanding of smart contracts

### Step 1: Initialize Project

```bash
# Create a new directory
mkdir safe-wallet-tutorial
cd safe-wallet-tutorial

# Initialize project
pnpm init -y
# or: npm init -y
# or: yarn init -y
```

### Step 2: Install Dependencies

```bash
# Using pnpm (recommended)
pnpm add @safe-global/relay-kit@^4.1.0 \
  @safe-global/protocol-kit@^5.2.1 \
  @safe-global/api-kit@^2.5.8 \
  dotenv@^16.4.7 \
  ethers@^6.13.5

pnpm add -D @types/node@^22.10.7 \
  ts-node@^10.9.2 \
  tsx@^4.20.6 \
  typescript@^5.7.3

# Or using npm
# npm install @safe-global/relay-kit@^4.1.0 @safe-global/protocol-kit@^5.2.1 @safe-global/api-kit@^2.5.8 dotenv@^16.4.7 ethers@^6.13.5
# npm install --save-dev @types/node@^22.10.7 ts-node@^10.9.2 tsx@^4.20.6 typescript@^5.7.3
```

### Step 3: Configure TypeScript

Create `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2021",
    "module": "ESNext",
    "lib": ["ES2021"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "declaration": true,
    "sourceMap": true,
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### Step 4: Update package.json

Add `"type": "module"` and scripts to your `package.json`:

```json
{
  "name": "safe-wallet-tutorial",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "predict-safe": "tsx src/examples/predict-safe.ts",
    "deploy-safe": "tsx src/examples/deploy-safe.ts",
    "transfer": "tsx src/examples/transfer.ts",
    "erc4337-transfer": "tsx src/examples/erc4337-transfer.ts"
  }
}
```

### Step 5: Environment Variables

Create a `.env` file in the project root:

```bash
# Network Configuration
RPC_URL=https://polygon-amoy.g.alchemy.com/v2/YOUR_API_KEY
CHAIN_ID=80002

# Private Keys (DO NOT COMMIT THESE!)
PRIVATE_KEY=0x...  # Your wallet private key
SENDER_KEY=0x...   # Alternative sender (or same as PRIVATE_KEY)

# For ERC-4337 (optional)
ALCHEMY_API_KEY=your_alchemy_api_key
GELATO_API_KEY=your_gelato_api_key

# Transfer recipient (optional)
TRANSFER_TO=0x26aCB57e5ee79342e959b50475455Df2C2018A37
```

### Step 6: Create .gitignore

Create `.gitignore` to protect your secrets:

```
node_modules/
dist/
.env
*.log
.DS_Store
```

---

## Quick Start: Your First Safe Transaction

Let's get something working immediately! Follow these steps to create and execute your first Safe transaction.

### Create Your First Script

Create `src/examples/predict-safe.ts`:

```typescript
import dotenv from 'dotenv';
dotenv.config();

// @ts-ignore - ESM interop
import SafeModule from '@safe-global/protocol-kit';
import { ethers } from 'ethers';

const Safe = (SafeModule as any)?.default || SafeModule;

// Configuration
const RPC_URL = process.env.RPC_URL!;
const PRIVATE_KEY = process.env.PRIVATE_KEY!;
const salt = "0x12345678912"; // Change this for different Safe addresses
const safeVersion = "1.4.1";
const deploymentType = "canonical";

async function predictSafe() {
  console.log('ðŸ”® Predicting Safe Address\n');

  try {
    const provider = new ethers.JsonRpcProvider(RPC_URL);
    const signer = new ethers.Wallet(PRIVATE_KEY, provider);

    console.log('Owner address:', signer.address);

    // Initialize Safe SDK
    const safeSdk = await Safe.init({
      provider: RPC_URL,
      predictedSafe: {
        safeAccountConfig: {
          owners: [signer.address],
          threshold: 1,
        },
        safeDeploymentConfig: {
          saltNonce: salt,
          safeVersion: safeVersion,
          deploymentType: deploymentType,
        },
      },
    });

    const predictedAddress = await safeSdk.getAddress();
    const isDeployed = await safeSdk.isSafeDeployed();

    console.log('âœ… Predicted Safe Address:', predictedAddress);
    console.log('ðŸ“Š Already deployed?', isDeployed ? 'Yes' : 'No');
    
    if (!isDeployed) {
      console.log('\nâš ï¸  Remember to fund this address before deploying!');
    }

  } catch (error) {
    console.error('âŒ Error:', error);
    process.exit(1);
  }
}

predictSafe();
```

### Run It!

```bash
# Make sure your .env is configured
pnpm run predict-safe
```

You should see your predicted Safe address! ðŸŽ‰

### Next: Deploy and Send Your First Transaction

Create `src/examples/deploy-and-transfer.ts`:

```typescript
import dotenv from 'dotenv';
dotenv.config();

// @ts-ignore - ESM interop
import SafeModule from '@safe-global/protocol-kit';
import { ethers } from 'ethers';

const Safe = (SafeModule as any)?.default || SafeModule;

const RPC_URL = process.env.RPC_URL!;
const PRIVATE_KEY = process.env.PRIVATE_KEY!;
const SENDER_KEY = process.env.SENDER_KEY || PRIVATE_KEY;
const TRANSFER_TO = process.env.TRANSFER_TO || "0x26aCB57e5ee79342e959b50475455Df2C2018A37";

const salt = "0x12345678912";
const safeVersion = "1.4.1";
const deploymentType = "canonical";

async function deployAndTransfer() {
  console.log('ðŸš€ Deploy Safe & Execute Transaction\n');

  try {
    const provider = new ethers.JsonRpcProvider(RPC_URL);
    const signer = new ethers.Wallet(PRIVATE_KEY, provider);
    const sender = new ethers.Wallet(SENDER_KEY, provider);

    // Initialize Safe SDK
    const safeSdk = await Safe.init({
      provider: RPC_URL,
      predictedSafe: {
        safeAccountConfig: {
          owners: [signer.address],
          threshold: 1,
        },
        safeDeploymentConfig: {
          saltNonce: salt,
          safeVersion: safeVersion,
          deploymentType: deploymentType,
        },
      },
    });

    const safeAddress = await safeSdk.getAddress();
    const isDeployed = await safeSdk.isSafeDeployed();

    console.log('Safe Address:', safeAddress);
    console.log('Is Deployed:', isDeployed);

    // Check Safe balance
    const safeBalance = await provider.getBalance(safeAddress);
    console.log('Safe Balance:', ethers.formatEther(safeBalance), 'ETH\n');

    if (safeBalance === 0n) {
      console.log('âš ï¸  Safe has no balance! Fund it first to execute transactions.');
      console.log(`   Send some testnet ETH to: ${safeAddress}\n`);
      return;
    }

    // Create transaction
    console.log('ðŸ“ Creating transaction...');
    const safeTx = await safeSdk.createTransaction({
      transactions: [{
        to: TRANSFER_TO,
        value: '1', // 1 wei
        data: '0x',
      }]
    });

    // Sign transaction
    console.log('âœï¸  Signing transaction...');
    const safeTxHash = await safeSdk.getTransactionHash(safeTx);
    const signingKey = new ethers.SigningKey(PRIVATE_KEY);
    const signature = signingKey.sign(safeTxHash);

    safeTx.addSignature({
      signer: signer.address,
      data: signature.serialized.toString(),
      isContractSignature: false,
    });

    let finalTx;

    if (!isDeployed) {
      console.log('ðŸ“¦ Wrapping in deployment batch...');
      finalTx = await safeSdk.wrapSafeTransactionIntoDeploymentBatch(safeTx);
    } else {
      console.log('ðŸ“¦ Encoding for execution...');
      const deployedSafeSdk = await Safe.init({
        provider: RPC_URL,
        safeAddress: safeAddress,
      });
      const encodedTx = await deployedSafeSdk.getEncodedTransaction(safeTx);
      finalTx = {
        to: safeAddress,
        value: '0',
        data: encodedTx,
      };
    }

    // Execute
    console.log('ðŸ“¡ Broadcasting transaction...');
    const txResponse = await sender.sendTransaction({
      to: finalTx.to,
      value: finalTx.value || '0',
      data: finalTx.data,
    });

    console.log('Transaction hash:', txResponse.hash);
    console.log('â³ Waiting for confirmation...\n');

    const receipt = await txResponse.wait();
    console.log('âœ… Transaction confirmed!');
    console.log('   Block:', receipt?.blockNumber);
    console.log('   Gas used:', receipt?.gasUsed.toString());

  } catch (error) {
    console.error('âŒ Error:', error);
    process.exit(1);
  }
}

deployAndTransfer();
```

### Run It!

```bash
# Add to package.json scripts:
# "deploy-and-transfer": "tsx src/examples/deploy-and-transfer.ts"

pnpm run deploy-and-transfer
```

**Congratulations! ðŸŽ‰** You just:
1. Predicted a Safe address
2. Deployed a Safe wallet (or used existing one)
3. Executed a transaction through it

---

## Understanding Safe Wallets

### What is Safe?

Safe (formerly Gnosis Safe) is a **multi-signature smart contract wallet** that provides:
- Multiple owners with customizable signature thresholds
- Modular architecture for extensibility
- Enhanced security through smart contract logic
- Support for account abstraction (ERC-4337)

### Key Concepts

#### 1. **Smart Contract Wallet**
Unlike EOAs (Externally Owned Accounts), Safe wallets are smart contracts. This means:
- The wallet address is a contract address
- Transactions must be executed through the Safe contract
- You can add custom logic and modules

#### 2. **Owners & Threshold**
- **Owners**: Addresses that can sign Safe transactions
- **Threshold**: Number of signatures required to execute a transaction
- Example: 2-of-3 multisig = 3 owners, 2 signatures needed

#### 3. **Modules**
Modules extend Safe functionality. For ERC-4337:
- **Safe 4337 Module v0.2.0**: EntryPoint v0.6 compatibility
- **Safe 4337 Module v0.3.0**: EntryPoint v0.7 compatibility

Module address (v0.3.0): `0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226`

#### 4. **Fallback Handler**
A contract that handles calls to functions not defined in the Safe contract. Required for ERC-4337 to validate user operations.

---

## Part 1: Basic Safe Operations (Protocol Kit)

The Protocol Kit provides low-level Safe operations that execute on-chain transactions directly.

### 1.1 Creating and Deploying a Safe

#### Predicting Safe Address

Before deploying, you can predict what address your Safe will have:

```typescript
import Safe from '@safe-global/protocol-kit';
import { ethers } from 'ethers';

const provider = new ethers.JsonRpcProvider(RPC_URL);
const signer = new ethers.Wallet(PRIVATE_KEY, provider);

// Configuration
const salt = "0x12345678912";      // Deterministic salt for address
const safeVersion = "1.4.1";       // Safe contract version
const deploymentType = "canonical"; // Deployment method

// Initialize Safe SDK with predicted configuration
const safeSdk = await Safe.init({
  provider: RPC_URL,
  predictedSafe: {
    safeAccountConfig: {
      owners: [signer.address],  // Safe owner(s)
      threshold: 1,              // Signatures required
    },
    safeDeploymentConfig: {
      saltNonce: salt,
      safeVersion: safeVersion,
      deploymentType: deploymentType,
    },
  },
});

// Get predicted address
const predictedAddress = await safeSdk.getAddress();
console.log('Predicted Safe Address:', predictedAddress);

// Check if already deployed
const isDeployed = await safeSdk.isSafeDeployed();
```

**Key Points:**
- The salt nonce makes the deployment deterministic
- Same configuration = same address across all chains
- You must fund this address before deploying

#### Deploying the Safe

Safe deployment can happen in two ways:

**Option A: Standalone Deployment**
```typescript
// Create deployment transaction
const deploymentTx = await safeSdk.createSafeDeploymentTransaction();

// Sign and send
const txResponse = await signer.sendTransaction({
  to: deploymentTx.to,
  data: deploymentTx.data,
  // ... gas configuration
});

await txResponse.wait();
```

**Option B: Deploy + Execute (Recommended)**
Combine deployment with the first transaction in a single batch:

```typescript
// Create your first Safe transaction
const safeTx = await safeSdk.createTransaction({
  transactions: [{
    to: recipientAddress,
    value: '1',
    data: '0x',
  }]
});

// Sign the Safe transaction
const safeTxHash = await safeSdk.getTransactionHash(safeTx);
const signature = signingKey.sign(safeTxHash);
safeTx.addSignature({
  signer: signer.address,
  data: signature.serialized.toString(),
  isContractSignature: false,
});

// Wrap into deployment batch (deploys + executes in one tx)
const finalTx = await safeSdk.wrapSafeTransactionIntoDeploymentBatch(safeTx);

// Execute with a funded EOA
const txResponse = await senderWallet.sendTransaction({
  to: finalTx.to,
  data: finalTx.data,
  // ... gas configuration
});
```

> **ðŸ’¡ Tip:** For a complete implementation, see the Quick Start example above or the reference implementation in `src/protocol-kit/safe-wallet.ts` (if available).

### 1.2 Executing Safe Transactions

Once deployed, executing Safe transactions follows this pattern:

```typescript
// 1. Initialize SDK with deployed Safe
const safeSdk = await Safe.init({
  provider: RPC_URL,
  safeAddress: SAFE_WALLET_ADDRESS,
});

// 2. Create transaction
const safeTx = await safeSdk.createTransaction({
  transactions: [{
    to: recipientAddress,
    value: '1000000',
    data: '0x',
  }]
});

// 3. Get transaction hash
const safeTxHash = await safeSdk.getTransactionHash(safeTx);

// 4. Sign with owner's key
const signingKey = new ethers.SigningKey(PRIVATE_KEY);
const signature = signingKey.sign(safeTxHash);

// 5. Add signature to transaction
safeTx.addSignature({
  signer: ownerAddress,
  data: signature.serialized.toString(),
  isContractSignature: false,
});

// 6. Encode for execution
const encodedTx = await safeSdk.getEncodedTransaction(safeTx);

// 7. Execute on-chain
const txResponse = await wallet.sendTransaction({
  to: SAFE_WALLET_ADDRESS,
  value: 0,
  data: encodedTx,
});

await txResponse.wait();
```

**Important Notes:**
- The Safe transaction must be signed by enough owners to meet the threshold
- The actual blockchain transaction can be sent by anyone (doesn't have to be an owner)
- The sender pays the gas fees

### 1.3 Getting Safe Information

Check Safe version and enabled modules:

```typescript
const safeSdk = await Safe.init({
  provider: RPC_URL,
  safeAddress: SAFE_WALLET_ADDRESS,
});

// Check deployment status
const isDeployed = await safeSdk.isSafeDeployed();

// Get Safe version
const version = await safeSdk.getContractVersion();

// Get enabled modules
const modules = await safeSdk.getModules();
console.log('Enabled modules:', modules);

// Get owners and threshold
const owners = await safeSdk.getOwners();
const threshold = await safeSdk.getThreshold();
```

### 1.4 Managing Modules

Modules extend Safe functionality. For ERC-4337, you need to enable the Safe 4337 Module.

#### Enabling a Module

```typescript
const MODULE_ADDRESS = "0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226";

// 1. Check if module is already enabled
const modules = await safeSdk.getModules();
const isEnabled = modules.includes(MODULE_ADDRESS);

if (!isEnabled) {
  // 2. Create enableModule transaction
  const safeContract = new ethers.Contract(
    SAFE_WALLET_ADDRESS,
    ["function enableModule(address module) external"],
    provider
  );
  
  const enableModuleData = safeContract.interface.encodeFunctionData(
    "enableModule",
    [MODULE_ADDRESS]
  );
  
  // 3. Create Safe transaction
  const safeTx = await safeSdk.createTransaction({
    transactions: [{
      to: SAFE_WALLET_ADDRESS,
      value: '0',
      data: enableModuleData,
    }]
  });
  
  // 4. Sign and execute (same pattern as above)
  // ... sign, encode, execute
}
```

#### Disabling a Module

```typescript
const SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";

// 1. Get current modules
const modules = await safeSdk.getModules();
const moduleIndex = modules.findIndex(m => 
  m.toLowerCase() === MODULE_ADDRESS.toLowerCase()
);

// 2. Determine previous module in the linked list
const prevModuleAddress = moduleIndex === 0 
  ? SENTINEL_ADDRESS 
  : modules[moduleIndex - 1];

// 3. Create disableModule transaction
const safeContract = new ethers.Contract(
  SAFE_WALLET_ADDRESS,
  ["function disableModule(address prevModule, address module) external"],
  provider
);

const disableModuleData = safeContract.interface.encodeFunctionData(
  "disableModule",
  [prevModuleAddress, MODULE_ADDRESS]
);

// 4. Create, sign, and execute Safe transaction
// ... (same pattern)
```

**Why prevModule?** Safe stores modules in a linked list. To remove a module, you need to provide the previous module in the list.

### 1.5 Setting Fallback Handler

The fallback handler is required for ERC-4337 compatibility:

```typescript
const FALLBACK_HANDLER_ADDRESS = "0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226";

// 1. Check current fallback handler
const currentHandler = await safeSdk.getFallbackHandler();

if (currentHandler?.toLowerCase() !== FALLBACK_HANDLER_ADDRESS.toLowerCase()) {
  // 2. Create setFallbackHandler transaction
  const safeContract = new ethers.Contract(
    SAFE_WALLET_ADDRESS,
    ["function setFallbackHandler(address handler) external"],
    provider
  );
  
  const setHandlerData = safeContract.interface.encodeFunctionData(
    "setFallbackHandler",
    [FALLBACK_HANDLER_ADDRESS]
  );
  
  // 3. Create, sign, and execute Safe transaction
  // ... (same pattern)
}
```

---

## Part 2: ERC-4337 User Operations (Relay Kit)

The Relay Kit enables ERC-4337 account abstraction, allowing gasless transactions, batching, and more.

### 2.1 Understanding ERC-4337

#### What is ERC-4337?

ERC-4337 is a standard for **Account Abstraction** without changing the Ethereum protocol. Key benefits:

- **Gasless Transactions**: Someone else can pay gas (paymaster)
- **Batched Operations**: Multiple actions in one transaction
- **Custom Validation**: Smart contract logic for transaction validation
- **Better UX**: Users don't need ETH for gas

#### Key Components

1. **User Operation (UserOp)**: Like a transaction but for smart contract wallets
2. **Bundler**: Collects UserOps and submits them on-chain
3. **EntryPoint**: On-chain contract that executes UserOps
4. **Paymaster**: (Optional) Contract that sponsors gas fees

#### EntryPoint Versions

- **EntryPoint v0.6**: `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789`
  - Uses Safe 4337 Module v0.2.0
- **EntryPoint v0.7**: `0x0000000071727De22E5E9d8BAf0edAc6f37da032`
  - Uses Safe 4337 Module v0.3.0 (newer, recommended)

### 2.2 Setting Up for ERC-4337

#### Prerequisites

1. **Safe Wallet Deployed**: Must have a Safe wallet already deployed
2. **Module Enabled**: Safe 4337 Module must be enabled
3. **Fallback Handler Set**: Fallback handler must point to the module
4. **Bundler Access**: Need access to a bundler (Alchemy, Gelato, or custom)

#### Configuration Helper

The `src/helpers/safeModules.ts` file provides module configurations:

```typescript
// Module configurations per chain
const SAFE_4337_CUSTOM_CONTRACTS_BY_CHAIN = {
  '80002': [ // Polygon Amoy
    {
      safe4337ModuleAddress: '0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226',
      safeModulesSetupAddress: '0x2dd68b007B46fBe91B9A7c3EDa5A7a1063cB5b47',
      safeModulesVersion: '0.3.0', // EntryPoint v0.7
    },
    {
      safe4337ModuleAddress: '0xa581c4A4DB7175302464fF3C06380BC3270b4037',
      safeModulesSetupAddress: '0x8EcD4ec46D4D2a6B64fE960B3D64e8B94B2234eb',
      safeModulesVersion: '0.2.0', // EntryPoint v0.6
    },
  ],
  // ... other chains
};

// Get configuration
const chainConfig = getSafe4337CustomContracts(CHAIN_ID, '0.3.0');
```

### 2.3 Self-Sponsored User Operations

User pays their own gas (Safe must have ETH balance).

```typescript
import { Safe4337Pack, SafeOperationFactory, createUserOperation } from '@safe-global/relay-kit';

const ENTRYPOINT_V07 = '0x0000000071727De22E5E9d8BAf0edAc6f37da032';
const BUNDLER_URL = `https://${network}.g.alchemy.com/v2/${ALCHEMY_API_KEY}`;

// 1. Initialize Safe4337Pack (for already deployed Safe)
const safe4337Pack = await Safe4337Pack.init({
  provider: RPC_URL,
  bundlerUrl: BUNDLER_URL,
  safeModulesVersion: '0.3.0',
  options: {
    owners: [wallet.address],
    threshold: 1,
    saltNonce: salt,
    safeVersion: '1.4.1',
    deploymentType: 'canonical',
  },
});

// 2. Create user operation
const transactions = [{
  to: recipientAddress,
  value: '1',
  data: '0x',
}];

const userOperation = await createUserOperation(
  safe4337Pack.protocolKit,
  transactions,
  {
    entryPoint: ENTRYPOINT_V07,
    paymasterOptions: undefined, // No paymaster = self-sponsored
  }
);

// 3. Create Safe operation
const safeOperation = SafeOperationFactory.createSafeOperation(
  userOperation,
  {
    chainId: BigInt(CHAIN_ID),
    moduleAddress: '0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226',
    entryPoint: ENTRYPOINT_V07,
    validUntil: undefined,
    validAfter: undefined,
  }
);

// 4. Estimate gas
const feeData = await provider.getFeeData();
const maxFeePerGas = feeData.maxFeePerGas || 30_000_000_000n;
const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas || 30_000_000_000n;

// Call bundler's eth_estimateUserOperationGas
const gasEstimation = await estimateAndApplyGas({
  safeOperation,
  bundlerUrl: BUNDLER_URL,
  entryPoint: ENTRYPOINT_V07,
  maxFeePerGas,
  maxPriorityFeePerGas,
});

safeOperation.addEstimations(gasEstimation);

// 5. Sign the operation
const operationHash = await safeOperation.getHash();
const signingKey = new ethers.SigningKey(PRIVATE_KEY);
const signature = signingKey.sign(operationHash);

safeOperation.addSignature({
  signer: wallet.address,
  data: signature.serialized.toString(),
  isContractSignature: false,
});

// 6. Submit to bundler
const userOpHash = await safe4337Pack.executeTransaction({
  executable: safeOperation,
});

console.log('UserOp Hash:', userOpHash);

// 7. Wait for confirmation
const receipt = await safe4337Pack.getUserOperationReceipt(userOpHash);
```

**Gas Estimation Process:**
The bundler's `eth_estimateUserOperationGas` endpoint simulates the operation and returns:
- `callGasLimit`: Gas for the actual execution
- `verificationGasLimit`: Gas for signature verification
- `preVerificationGas`: Fixed gas for bundler overhead

### 2.4 Sponsored User Operations (Gelato)

With Gelato sponsoring, transactions are free for the user:

```typescript
const BUNDLER_URL = `https://api.gelato.digital/bundlers/${CHAIN_ID}/rpc?apiKey=${GELATO_API_KEY}&sponsored=true`;

// Initialize (same as above)
const safe4337Pack = await Safe4337Pack.init({
  provider: RPC_URL,
  bundlerUrl: BUNDLER_URL,
  safeModulesVersion: '0.3.0',
  // ...
});

// Create user operation
const userOperation = await createUserOperation(
  safe4337Pack.protocolKit,
  transactions,
  {
    entryPoint: ENTRYPOINT_V07,
    paymasterOptions: undefined, // Gelato handles sponsoring via URL
  }
);

// For Gelato, set gas fields to 0
userOperation.preVerificationGas = 0n;
userOperation.maxFeePerGas = 0n;
userOperation.maxPriorityFeePerGas = 0n;

// Remove paymaster fields (Gelato adds them during estimation)
delete userOperation.paymaster;
delete userOperation.paymasterData;
delete userOperation.paymasterVerificationGasLimit;
delete userOperation.paymasterPostOpGasLimit;

// Create Safe operation and continue as before...
```

**Key Differences:**
- Bundler URL includes `sponsored=true`
- Gas fees are set to 0
- Gelato's bundler automatically adds paymaster information
- Safe doesn't need ETH balance

### 2.5 Parallel Execution with Nonce Keys

ERC-4337 supports parallel execution using different nonce keys:

```typescript
const ENTRY_POINT_ABI = [
  "function getNonce(address sender, uint192 key) view returns (uint256)"
];

// Get nonce for a specific key
async function getEntryPointNonce(
  provider: any,
  entryPoint: string,
  safeAddress: string,
  nonceKey: string
): Promise<bigint> {
  const entryPointContract = new ethers.Contract(
    entryPoint,
    ENTRY_POINT_ABI,
    provider
  );
  
  const nonce = await entryPointContract.getNonce(
    safeAddress,
    BigInt(nonceKey)
  );
  
  return nonce;
}

// Execute with custom nonce key
async function executeWithNonceKey(nonceKey: string) {
  // ... initialize safe4337Pack
  
  // Create user operation
  const userOperation = await createUserOperation(
    safe4337Pack.protocolKit,
    transactions,
    { entryPoint: ENTRYPOINT_V07 }
  );
  
  // Override nonce with nonce from specific key
  const onChainNonce = await getEntryPointNonce(
    provider,
    ENTRYPOINT_V07,
    safeAddress,
    nonceKey
  );
  
  userOperation.nonce = `0x${onChainNonce.toString(16)}`;
  
  // Continue with signing and submission...
}

// Execute multiple operations in parallel
async function executeInParallel() {
  const nonceKeys = ['0x1', '0x2', '0x3'];
  
  const results = await Promise.all(
    nonceKeys.map(key => executeWithNonceKey(key))
  );
  
  return results;
}
```

**How Nonce Keys Work:**
- EntryPoint tracks nonces per Safe address AND per key
- Each key has its own sequential nonce (0, 1, 2, ...)
- Operations with different keys can execute in parallel
- Operations with the same key must execute sequentially

**Use Cases:**
- Parallel transaction submission for faster throughput
- Different sessions or contexts within the same wallet
- Avoiding nonce conflicts in high-frequency applications

---

## Part 3: Advanced Topics

### 3.1 Migrating from EntryPoint v0.6 to v0.7

If you have an existing Safe with the v0.2.0 module (EntryPoint v0.6), upgrade to v0.3.0:

#### Step 1: Enable v0.7 Module

```bash
# Update MODULE_ADDRESS in enable-module.ts
MODULE_ADDRESS="0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226"

yarn enable-module
```

#### Step 2: Set Fallback Handler

```bash
# Update FALLBACK_HANDLER_ADDRESS in set-fallback-handler.ts
FALLBACK_HANDLER_ADDRESS="0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226"

yarn set-fallback-handler
```

#### Step 3: Verify

```bash
# Check the module exposes v0.7 EntryPoint
cast call 0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226 \
  "SUPPORTED_ENTRYPOINT()" \
  --rpc-url $RPC_URL

# Should return: 0x0000000071727De22E5E9d8BAf0edAc6f37da032 (EntryPoint v0.7)
```

Or programmatically:

```bash
yarn get-safe-version
```

### 3.2 Gas Estimation Best Practices

#### Adding Buffer to Gas Estimates

Always add a buffer to gas estimates to avoid out-of-gas errors:

```typescript
function addBuffer(
  value: string,
  bufferPercent: number = 5,
  minBuffer: number = 1000
): string {
  const numValue = BigInt(value);
  const buffer = numValue * BigInt(bufferPercent) / BigInt(100);
  const minBufferBigInt = BigInt(minBuffer);
  const finalBuffer = buffer > minBufferBigInt ? buffer : minBufferBigInt;
  const finalValue = numValue + finalBuffer;
  return '0x' + finalValue.toString(16);
}

const callGasLimit = addBuffer(estimatedGas.callGasLimit, 5, 1000);
```

#### Handling Estimation Failures

```typescript
try {
  const estimated = await provider.estimateGas(txPayload);
  gasLimit = (estimated * 120n) / 100n; // 20% buffer
} catch (error) {
  console.warn('Gas estimation failed, transaction may fail');
  // Use default or throw
  throw new Error('Gas estimation required');
}
```

### 3.3 Understanding UserOperation Structure

A UserOperation contains:

```typescript
{
  sender: string;           // Safe address
  nonce: string;            // Sequential nonce (or with key)
  callData: string;         // Encoded transaction data
  callGasLimit: string;     // Gas for execution
  verificationGasLimit: string;  // Gas for validation
  preVerificationGas: string;    // Bundler overhead
  maxFeePerGas: string;          // EIP-1559 max fee
  maxPriorityFeePerGas: string;  // EIP-1559 priority fee
  signature: string;        // Owner signature(s)
  
  // EntryPoint v0.6
  initCode?: string;        // Deployment code (if not deployed)
  paymasterAndData?: string;  // Paymaster info (if sponsored)
  
  // EntryPoint v0.7
  factory?: string;         // Factory address (if not deployed)
  factoryData?: string;     // Factory call data
  paymaster?: string;       // Paymaster address
  paymasterData?: string;   // Paymaster call data
  paymasterVerificationGasLimit?: string;
  paymasterPostOpGasLimit?: string;
}
```

### 3.4 Bundler Communication

Bundlers implement these RPC methods:

```typescript
// Estimate gas for user operation
eth_estimateUserOperationGas(userOp, entryPoint)

// Submit user operation
eth_sendUserOperation(userOp, entryPoint)

// Get user operation by hash
eth_getUserOperationByHash(hash)

// Get user operation receipt
eth_getUserOperationReceipt(hash)
```

Example direct bundler call:

```typescript
const response = await fetch(BUNDLER_URL, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    jsonrpc: '2.0',
    method: 'eth_sendUserOperation',
    params: [userOperationHex, entryPoint],
    id: Date.now(),
  }),
});

const result = await response.json();
const userOpHash = result.result;
```

### 3.5 Signature Formats

Safe supports multiple signature formats:

```typescript
// EOA signature (most common)
{
  signer: '0x...',                    // Signer address
  data: '0x...',                      // Signature bytes
  isContractSignature: false,
}

// Contract signature (for smart contract signers)
{
  signer: '0x...',                    // Contract address
  data: '0x...',                      // Signature data
  isContractSignature: true,
}
```

For ERC-4337, you sign the `SafeOperation` hash:

```typescript
const operationHash = await safeOperation.getHash();
const signature = signingKey.sign(operationHash);

safeOperation.addSignature({
  signer: wallet.address,
  data: signature.serialized.toString(),
  isContractSignature: false,
});
```

### 3.6 Multi-Signature Scenarios

For multi-sig Safes (threshold > 1):

```typescript
// Each owner signs
const operationHash = await safeOperation.getHash();

const owner1Signature = signingKey1.sign(operationHash);
const owner2Signature = signingKey2.sign(operationHash);

// Add all required signatures
safeOperation.addSignature({
  signer: owner1Address,
  data: owner1Signature.serialized.toString(),
  isContractSignature: false,
});

safeOperation.addSignature({
  signer: owner2Address,
  data: owner2Signature.serialized.toString(),
  isContractSignature: false,
});

// Submit once threshold is met
```

---

## Troubleshooting

### Common Issues

#### 1. "Safe not deployed"

**Problem:** Trying to use a Safe that doesn't exist on-chain.

**Solution:**
```typescript
const isDeployed = await safeSdk.isSafeDeployed();
if (!isDeployed) {
  // Either deploy first or use deployment batch
  const deploymentBatch = await safeSdk.wrapSafeTransactionIntoDeploymentBatch(safeTx);
}
```

#### 2. "Module not enabled"

**Problem:** Trying to use ERC-4337 without enabling the module.

**Solution:**
```bash
# Enable the module first
yarn enable-module
```

#### 3. "Insufficient balance"

**Problem:** Safe doesn't have enough ETH for the operation.

**For Protocol Kit:** Fund the Safe address with ETH.

**For ERC-4337 (self-sponsored):** Fund the Safe with ETH for gas.

**For ERC-4337 (sponsored):** Make sure bundler sponsoring is configured correctly.

#### 4. "Gas estimation failed"

**Problem:** Bundler can't estimate gas for the operation.

**Common causes:**
- Safe not funded (for self-sponsored)
- Transaction will revert
- Bundler doesn't support your operation
- Wrong EntryPoint version

**Debug:**
```typescript
// Check if Safe has balance
const balance = await provider.getBalance(safeAddress);
console.log('Safe balance:', ethers.formatEther(balance));

// Try with lower operations complexity
// Verify EntryPoint matches module version
```

#### 5. "Invalid signature"

**Problem:** Signature doesn't match the expected signer.

**Solution:**
```typescript
// Verify signer address matches owner
const owners = await safeSdk.getOwners();
console.log('Safe owners:', owners);
console.log('Signing with:', signerAddress);

// Make sure you're signing the correct hash
const operationHash = await safeOperation.getHash();
console.log('Hash to sign:', operationHash);
```

#### 6. "Nonce mismatch"

**Problem:** Using wrong nonce for the operation.

**For Protocol Kit:** Safe maintains its own nonce, usually handled automatically.

**For ERC-4337:**
```typescript
// Get the correct nonce from EntryPoint
const nonce = await entryPointContract.getNonce(safeAddress, nonceKey);
console.log('Current nonce:', nonce);

// Make sure your UserOp uses this nonce
userOperation.nonce = `0x${nonce.toString(16)}`;
```

#### 7. "Bundler rejected operation"

**Problem:** Bundler refuses to accept your UserOp.

**Common reasons:**
- Gas fees too low
- Operation too complex
- Paymaster issues (if using one)
- EntryPoint version mismatch

**Debug:**
```typescript
// Log the full UserOp before submission
console.log('UserOperation:', JSON.stringify(userOperation, null, 2));

// Check bundler-specific requirements
// Some bundlers have minimum gas requirements
```

### Network-Specific Notes

#### Polygon Amoy (Chain ID: 80002)
- Use Alchemy or custom bundler
- Module v0.3.0 address: `0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226`
- EntryPoint v0.7: `0x0000000071727De22E5E9d8BAf0edAc6f37da032`

#### Sepolia (Chain ID: 11155111)
- Alchemy bundler supported
- Gelato bundler supported
- Same module addresses as Amoy

#### Base Sepolia (Chain ID: 84532)
- Alchemy bundler: `base-sepolia.g.alchemy.com`
- Check module deployment status

### Debugging Tips

1. **Enable verbose logging:**
```typescript
console.log('Safe address:', await safeSdk.getAddress());
console.log('Is deployed:', await safeSdk.isSafeDeployed());
console.log('Modules:', await safeSdk.getModules());
console.log('Fallback handler:', await safeSdk.getFallbackHandler());
```

2. **Verify on block explorer:**
- Check Safe contract on Etherscan/Polygonscan
- Verify module is enabled
- Check transaction history

3. **Test with small amounts:**
- Always test with small ETH amounts first
- Use testnet tokens before mainnet

4. **Check bundler status:**
```bash
# Ping bundler
curl -X POST $BUNDLER_URL \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}'
```

---

## Additional Resources

### Documentation
- [Safe Protocol Kit Docs](https://docs.safe.global/sdk/protocol-kit)
- [Safe Relay Kit Docs](https://docs.safe.global/sdk/relay-kit)
- [ERC-4337 Specification](https://eips.ethereum.org/EIPS/eip-4337)
- [Safe Smart Account Networks](https://docs.safe.global/advanced/smart-account-supported-networks)

### Block Explorers
- [JiffyScan (UserOp Explorer)](https://jiffyscan.xyz/)
- [Safe Transaction Service](https://safe-transaction-mainnet.safe.global/)

### Bundler Services
- [Alchemy Account Kit](https://www.alchemy.com/account-kit)
- [Gelato Relay](https://www.gelato.network/relay)

### Tools
- [Safe CLI](https://github.com/safe-global/safe-cli)
- [Foundry (cast)](https://book.getfoundry.sh/cast/)

---

## Summary

This tutorial covered:

1. **Basic Safe Operations**: Creating, deploying, and executing Safe transactions using Protocol Kit
2. **Module Management**: Enabling/disabling modules and setting fallback handlers for ERC-4337
3. **ERC-4337 Basics**: Understanding user operations and account abstraction
4. **Self-Sponsored UserOps**: Executing operations where the Safe pays gas
5. **Sponsored UserOps**: Gasless transactions using Gelato
6. **Parallel Execution**: Using nonce keys for concurrent operations
7. **Advanced Topics**: Gas estimation, signature handling, and multi-sig scenarios
8. **Troubleshooting**: Common issues and how to resolve them

---

## Complete Project Structure

For quick reference, here's what your final project should look like:

```
safe-wallet-tutorial/
â”œâ”€â”€ .env                          # Your environment variables (DO NOT COMMIT!)
â”œâ”€â”€ .gitignore                    # Protect your secrets
â”œâ”€â”€ package.json                  # Dependencies and scripts
â”œâ”€â”€ tsconfig.json                 # TypeScript configuration
â””â”€â”€ src/
    â””â”€â”€ examples/
        â”œâ”€â”€ predict-safe.ts           # Quick Start example 1
        â””â”€â”€ deploy-and-transfer.ts    # Quick Start example 2
```

### Minimum Working Setup

These are the **only files you need** to get started:

1. **`.env`** - Your configuration (copy from Step 5 above)
2. **`package.json`** - Dependencies (from Step 2 & 4)
3. **`tsconfig.json`** - TypeScript config (from Step 3)
4. **`.gitignore`** - Protect secrets (from Step 6)
5. **`src/examples/predict-safe.ts`** - First working script (from Quick Start)
6. **`src/examples/deploy-and-transfer.ts`** - Second working script (from Quick Start)

Once you have these files, run:

```bash
pnpm install
pnpm run predict-safe
```

And you're off! ðŸš€

### What's Next?

After getting the Quick Start working:

1. **Experiment** - Modify the salt, try different transactions
2. **Add Features** - Implement module management, multi-sig, etc.
3. **Try ERC-4337** - Use the code examples in Part 2 to create gasless transactions
4. **Build Your App** - Integrate Safe into your dApp

---

**Happy Building! ðŸš€**

